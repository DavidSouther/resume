<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/fef2051bebc1224a.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/188c8aff756c3f67.css" data-precedence="next"/><link rel="preload" href="/_next/static/chunks/webpack-aeac45c82ebe15f5.js" as="script" fetchPriority="low"/><script src="/_next/static/chunks/fd9d1056-edf0048f965d11ef.js" async=""></script><script src="/_next/static/chunks/596-e3269281f6a80cbc.js" async=""></script><script src="/_next/static/chunks/main-app-9c0e3b85b1eb37c3.js" async=""></script><link rel="preload" as="script" href="https://www.googletagmanager.com/gtag/js?id=G-6X1Z1L95D8"/><title>Forward/Backward Method for Algorithms - David Souther</title><meta name="description" content="davidsouther.com - resume, blog, playground"/><link rel="author" href="davidsouther.com"/><meta name="author" content="David Souther"/><link rel="manifest" href="/manifest.json"/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="black"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/jiffies-css-bundle.min.css"/><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="container"><article class="blog-page_BlogPage__t8vJA"><header><h3><a href="/">David Souther</a> - <!-- -->Forward/Backward Method for Algorithms<!-- --> - <!-- -->2024-08-13</h3></header><main><div><h1>The Forward/Backward Method for Developing Algorithms (Example: Circular Linked List)</h1>
<p>Part three of a series on <a href="https://davidsouther.com/blog/interview_01_whiteboard">technical whiteboarding</a>.</p>
<p>Developing an algorithm for an unknown, novel programming problem can be a daunting task. The Forward/Backward method is a consistent, repeatable approach that guides a developer towards a correct &#x26; robust solution. It begins with brainstorming two or three specific test case datasets for the problem</p>
<p><img src="/images/Technical_Whiteboarding_FB_0.png" alt="Example circular linked lists"></p>
<p>This example develops an algorithm to detect whether a linked list has a cycle. A cycle happens when a node links “back” earlier in the list. Here, the programmer has created two linked lists, one with and one without a cycle. Visually it is easy to see the cycle as the arrow that goes back to earlier in the first example, and the absence of such an arrow in the second.</p>
<p>The forward/backward process is a problem solving technique to break a large problem into a series of smaller steps. It begins by working from the bottom up, or backwards. Start by drawing the inputs in the top of the working area, and the output at the bottom. If the inputs and output are containers with a generic data type, prefer to draw them using shapes and colors rather than making up specific words or numbers.</p>
<p><img src="/images/Technical_Whiteboarding_FB_1.png" alt="Forward/backward: inputs and outputs"></p>
<p>The inputs and outputs have been written at the top and bottom, respectively, and labeled A1forward and B1 backward. The programmer then asks, “what information did I use to decide on the values false and true?”</p>
<p>After this drawing, the output for a test case is at the bottom of the visualization and the input is at the top. Call the output B1 and the input A1. Looking at the output, ask what is the immediate precursor information necessary to find that value. This Key Question drives much of the forward backward process - “What is the immediate piece of information that gives this data?” when working backwards, and “what information can I immediately derive, generate, or fill in?” moving forward.</p>
<p><img src="/images/Technical_Whiteboarding_FB_2.png" alt="Forward/backward: B2"></p>
<p>The first answer to the question “What information did I use to decide on the values false and true?” was that the arrow “points” backwards. Unfortunately, the “direction” of an arrow isn’t part of the definition of a linked list, which only includes the “next” pointer but not where that goes in relation to the current node. However, the programmer notices that a traversal of the linked list would have already seen the blue node in the example on the right; on the left, it would have completed and only seen each node once. This answer to the question fills in step B2.</p>
<p>For example, if the output is a boolean value, the immediate precursor operation is a comparison. Draw the two values and how they were compared. Or if the output is a list, notate the change that created the output, and draw the list in its previous state directly above B1. This precursor to the output step B1 is step B2. Repeat this process. In the comparison example, where did the two values come from? If it was a change to a data structure, where did the information for the change come from? Draw the source of those values as step B3.</p>
<p><img src="/images/Technical_Whiteboarding_FB_3.png" alt="Forward/backward: B3"></p>
<p>Applying the key question again, “what information did I use to get this data?”, the programmer recognizes they used a set to track which nodes had and had not been seen. This set structure is B3.</p>
<p>After some number of steps working backwards, an intermediate data structure should become apparent that provides the information needed to work forwards to B1. Now, work forwards from A1 to this intermediate step. Describe the creation of the data structure, any loops necessary to convert the input to that, and any additional information that might be needed or useful. These forward steps are A2, A3, etc.</p>
<p><img src="/images/Technical_Whiteboarding_FB_4.png" alt="Forward/backward: A2"></p>
<p>Having moved backwards to needing a visited set data structure, the programmer observes “What information can I fill in?”, the forward key question, is the visited set found in step B3. A traversal of the list, storing each item in the set, is forward step A2. At this point, there is a complete thread of logic and small steps from A1 (the input), to A2 (filling in a visited list during a traversal) to B3 (checking the visited list during the traversal), to B2 (seeing (or not seeing) a duplicate item, to B1, returning immediately when a duplicate is seen, or when the traversal has completed.</p>
<p>When the forward and backward steps line up in the visualization using specific values, it’s time to write a general plain language description of each step. These steps should not be specific to any programming language. They should use “big picture” holistic operations, like “traverse the list”, “compare the values”, or “check the set”. Calling out intermediate data structures by variable name is appropriate, but describing the changes to a loop variable i is too detailed for a general algorithm.</p>
<p><img src="/images/Technical_Whiteboarding_FB_Algorithm.png" alt="Completed visualization and algorithm"></p>
<p>This write up describes the forward and backward steps in an algorithmic way. It doesn’t deal with details of the function name or argument variables, but does call out specific names for the set and the traversal variable for the set. It uses concise If statements, and generic operations on the intermediate data structures.</p>
<p>This approach to problem solving works best with a good understanding and recognition of the common data structures, their methods, and the algorithms to work on. While any problem may need specific domain knowledge, generally, knowing how to construct and traverse arrays, linked lists, binary trees, n-ary child trees, and hashmaps, as well as how stacks, queues, and sets augment traversals for those structures, is a solid starting point.</p>
<h2>Recursive Algorithms</h2>
<p>A problem may have a very clear recursive solution. When the problem can be rephrased as “Do the same operation on two parts of the input”, or “do the operation on the head, and then repeat”, it might be amenable to recursion. Recursion requires two pieces: the base case, and the operation. Identify the base case (usually either empty or one item in the data structure), the recursion on one or more parts of the data structure, and any logic necessary to combine those results.</p>
<p>In recursion, the empty case becomes critical to identify, as this case (and possibly the one or two item case) will come to define the base case of the recursion. Failure to identify the base case at this time will greatly increase the difficulty in the remainder of the interview.</p>
<h1>References</h1>
<p>SOLOW, D. 2014. Chapter 2, The Forward Backward Method. In How to Read and Do Proofs (Sixth Edition). John Wiley &#x26; Sons, Danvers, MA, 9-24</p>
</div></main><footer><a href="../../">Back</a></footer></article><script src="/_next/static/chunks/webpack-aeac45c82ebe15f5.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/fef2051bebc1224a.css\",{\"as\":\"style\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:HL[\"/_next/static/css/188c8aff756c3f67.css\",{\"as\":\"style\"}]\n"])</script><script>self.__next_f.push([1,"4:I{\"id\":7948,\"chunks\":[\"272:static/chunks/webpack-aeac45c82ebe15f5.js\",\"971:static/chunks/fd9d1056-edf0048f965d11ef.js\",\"596:static/chunks/596-e3269281f6a80cbc.js\"],\"name\":\"default\",\"async\":false}\n6:I{\"id\":6628,\"chunks\":[\"272:static/chunks/webpack-aeac45c82ebe15f5.js\",\"971:static/chunks/fd9d1056-edf0048f965d11ef.js\",\"596:static/chunks/596-e3269281f6a80cbc.js\"],\"name\":\"\",\"async\":false}\n7:I{\"id\":7767,\"chunks\":[\"272:static/chunks/webpack-aeac45c82ebe15f5.js\",\"971:static/chunks/fd9d1056-edf0048f965d11ef.js\",\"5"])</script><script>self.__next_f.push([1,"96:static/chunks/596-e3269281f6a80cbc.js\"],\"name\":\"default\",\"async\":false}\n8:I{\"id\":7920,\"chunks\":[\"272:static/chunks/webpack-aeac45c82ebe15f5.js\",\"971:static/chunks/fd9d1056-edf0048f965d11ef.js\",\"596:static/chunks/596-e3269281f6a80cbc.js\"],\"name\":\"default\",\"async\":false}\nb:I{\"id\":6852,\"chunks\":[\"13:static/chunks/13-a14f4f8488530559.js\",\"599:static/chunks/599-57c8542fa14d7dc7.js\",\"185:static/chunks/app/layout-69f12350d3705464.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/fef2051bebc1224a.css\",\"precedence\":\"next\"}]],[\"$\",\"$L4\",null,{\"buildId\":\"aGqQErIkoIOsd7PFUynAp\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/blog/interview_04_forward_backward\",\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"id\",\"interview_04_forward_backward\",\"d\"],{\"children\":[\"__PAGE__?{\\\"id\\\":\\\"interview_04_forward_backward\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L5\"],\"globalErrorComponent\":\"$6\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"/jiffies-css-bundle.min.css\"}]}],[\"$\",\"body\",null,{\"className\":\"container\",\"children\":[[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"childProp\":{\"current\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",[\"id\",\"interview_04_forward_backward\",\"d\"],\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$L9\",\"$La\",null],\"segment\":\"__PAGE__?{\\\"id\\\":\\\"interview_04_forward_backward\\\"}\"},\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/188c8aff756c3f67.css\",\"precedence\":\"next\"}]]}],\"segment\":[\"id\",\"interview_04_forward_backward\",\"d\"]},\"styles\":[]}],\"segment\":\"blog\"},\"styles\":[]}],[\"$\",\"$Lb\",null,{}]]}]]}],null]}]]\n"])</script><script>self.__next_f.push([1,"c:I{\"id\":7839,\"chunks\":[\"548:static/chunks/app/blog/[id]/page-6269816b04da5638.js\"],\"name\":\"Card\",\"async\":false}\nd:T1cab,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eThe Forward/Backward Method for Developing Algorithms (Example: Circular Linked List)\u003c/h1\u003e\n\u003cp\u003ePart three of a series on \u003ca href=\"https://davidsouther.com/blog/interview_01_whiteboard\"\u003etechnical whiteboarding\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eDeveloping an algorithm for an unknown, novel programming problem can be a daunting task. The Forward/Backward method is a consistent, repeatable approach that guides a developer towards a correct \u0026#x26; robust solution. It begins with brainstorming two or three specific test case datasets for the problem\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/Technical_Whiteboarding_FB_0.png\" alt=\"Example circular linked lists\"\u003e\u003c/p\u003e\n\u003cp\u003eThis example develops an algorithm to detect whether a linked list has a cycle. A cycle happens when a node links “back” earlier in the list. Here, the programmer has created two linked lists, one with and one without a cycle. Visually it is easy to see the cycle as the arrow that goes back to earlier in the first example, and the absence of such an arrow in the second.\u003c/p\u003e\n\u003cp\u003eThe forward/backward process is a problem solving technique to break a large problem into a series of smaller steps. It begins by working from the bottom up, or backwards. Start by drawing the inputs in the top of the working area, and the output at the bottom. If the inputs and output are containers with a generic data type, prefer to draw them using shapes and colors rather than making up specific words or numbers.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/Technical_Whiteboarding_FB_1.png\" alt=\"Forward/backward: inputs and outputs\"\u003e\u003c/p\u003e\n\u003cp\u003eThe inputs and outputs have been written at the top and bottom, respectively, and labeled A1forward and B1 backward. The programmer then asks, “what information did I use to decide on the values false and true?”\u003c/p\u003e\n\u003cp\u003eAfter this drawing, the output for a test case is at the bottom of the visualization and the input is at the top. Call the output B1 and the input A1. Looking at the output, ask what is the immediate precursor information necessary to find that value. This Key Question drives much of the forward backward process - “What is the immediate piece of information that gives this data?” when working backwards, and “what information can I immediately derive, generate, or fill in?” moving forward.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/Technical_Whiteboarding_FB_2.png\" alt=\"Forward/backward: B2\"\u003e\u003c/p\u003e\n\u003cp\u003eThe first answer to the question “What information did I use to decide on the values false and true?” was that the arrow “points” backwards. Unfortunately, the “direction” of an arrow isn’t part of the definition of a linked list, which only includes the “next” pointer but not where that goes in relation to the current node. However, the programmer notices that a traversal of the linked list would have already seen the blue node in the example on the right; on the left, it would have completed and only seen each node once. This answer to the question fills in step B2.\u003c/p\u003e\n\u003cp\u003eFor example, if the output is a boolean value, the immediate precursor operation is a comparison. Draw the two values and how they were compared. Or if the output is a list, notate the change that created the output, and draw the list in its previous state directly above B1. This precursor to the output step B1 is step B2. Repeat this process. In the comparison example, where did the two values come from? If it was a change to a data structure, where did the information for the change come from? Draw the source of those values as step B3.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/Technical_Whiteboarding_FB_3.png\" alt=\"Forward/backward: B3\"\u003e\u003c/p\u003e\n\u003cp\u003eApplying the key question again, “what information did I use to get this data?”, the programmer recognizes they used a set to track which nodes had and had not been seen. This set structure is B3.\u003c/p\u003e\n\u003cp\u003eAfter some number of steps working backwards, an intermediate data structure should become apparent that provides the information needed to work forwards to B1. Now, work forwards from A1 to this intermediate step. Describe the creation of the data structure, any loops necessary to convert the input to that, and any additional information that might be needed or useful. These forward steps are A2, A3, etc.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/Technical_Whiteboarding_FB_4.png\" alt=\"Forward/backward: A2\"\u003e\u003c/p\u003e\n\u003cp\u003eHaving moved backwards to needing a visited set data structure, the programmer observes “What information can I fill in?”, the forward key question, is the visited set found in step B3. A traversal of the list, storing each item in the set, is forward step A2. At this point, there is a complete thread of logic and small steps from A1 (the input), to A2 (filling in a visited list during a traversal) to B3 (checking the visited list during the traversal), to B2 (seeing (or not seeing) a duplicate item, to B1, returning immediately when a duplicate is seen, or when the traversal has completed.\u003c/p\u003e\n\u003cp\u003eWhen the forward and backward steps line up in the visualization using specific values, it’s time to write a general plain language description of each step. These steps should not be specific to any programming language. They should use “big picture” holistic operations, like “traverse the list”, “compare the values”, or “check the set”. Calling out intermediate data structures by variable name is appropriate, but describing the changes to a loop variable i is too detailed for a general algorithm.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/Technical_Whiteboarding_FB_Algorithm.png\" alt=\"Completed visualization and algorithm\"\u003e\u003c/p\u003e\n\u003cp\u003eThis write up describes the forward and backward steps in an algorithmic way. It doesn’t deal with details of the function name or argument variables, but does call out specific names for the set and the traversal variable for the set. It uses concise If statements, and generic operations on the intermediate data structures.\u003c/p\u003e\n\u003cp\u003eThis approach to problem solving works best with a good understanding and recognition of the common data structures, their methods, and the algorithms to work on. While any problem may need specific domain knowledge, generally, knowing how to construct and traverse arrays, linked lists, binary trees, n-ary child trees, and hashmaps, as well as how stacks, queues, and sets augment traversals for those structures, is a solid starting point.\u003c/p\u003e\n\u003ch2\u003eRecursive Algorithms\u003c/h2\u003e\n\u003cp\u003eA problem may have a very clear recursive solution. When the problem can be rephrased as “Do the same operation on two parts of the input”, or “do the operation on the head, and then repeat”, it might be amenable to recursion. Recursion requires two pieces: the base case, and the operation. Identify the base case (usually either empty or one item in the data structure), the recursion on one or more parts of the data structure, and any logic necessary to combine those results.\u003c/p\u003e\n\u003cp\u003eIn recursion, the empty case becomes critical to identify, as this case (and possibly the one or two item case) will come to define the base case of the recursion. Failure to identify the base case at this time will greatly increase the difficulty in the remainder of the interview.\u003c/p\u003e\n\u003ch1\u003eReferences\u003c/h1\u003e\n\u003cp\u003eSOLOW, D. 2014. Chapter 2, The Forward Backward Method. In How to Read and Do Proofs (Sixth Edition). John Wiley \u0026#x26; Sons, Danvers, MA, 9-24\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"a:[\"$\",\"$Lc\",null,{\"header\":[[\"$\",\"a\",null,{\"href\":\"/\",\"children\":\"David Souther\"}],\" - \",\"Forward/Backward Method for Algorithms\",\" - \",\"2024-08-13\"],\"footer\":[\"$\",\"a\",null,{\"href\":\"../../\",\"children\":\"Back\"}],\"className\":\"blog-page_BlogPage__t8vJA\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}]\n"])</script><script>self.__next_f.push([1,"5:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Forward/Backward Method for Algorithms - David Souther\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"davidsouther.com - resume, blog, playground\"}],[\"$\",\"link\",\"3\",{\"rel\":\"author\",\"href\":\"davidsouther.com\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"David Souther\"}],[\"$\",\"link\",\"5\",{\"rel\":\"manifest\",\"href\":\"/manifest.json\"}],[\"$\",\"meta\",\"6\",{\"name\":\"theme-color\",\"media\":\"(prefers-color-scheme: light)\",\"content\":\"white\"}],[\"$\",\"meta\",\"7\",{\"name\":\"theme-color\",\"media\":\"(prefers-color-scheme: dark)\",\"content\":\"black\"}],[\"$\",\"meta\",\"8\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:card\",\"content\":\"summary\"}]]\n"])</script><script>self.__next_f.push([1,"9:null\n"])</script></body></html>